Предлагаю такой план для способа 1 (сервер управляет ключом, клиент не видит креды):
1)
Где хранить B2 креды:
◦
Коллекция users/{uid}/settings/b2 в Firestore: keyId, applicationKey, bucketId, bucketName, endpoint?.
◦
Хранить зашифрованно серверным ключом (одним для всего сервиса) или через KMS (если доступно). Ключ берётся из приватного env на Netlify (например, B2_SECRET_KEY), доступен только в серверных функциях.
2)
UI для ввода/редактирования:
◦
Страница Settings: форма “Backblaze credentials” (keyId, applicationKey, bucketId, bucketName, endpoint).
◦
Кнопки: “Сохранить” (записывает на сервер), “Проверить соединение” (опционально вызывает сервер для b2_authorize_account и проверяет bucket).
◦
Показ состояния: “сохранено”, “ошибка”.
3)
Серверные эндпоинты (auth на user.uid):
◦
GET /api/user/b2 — возвращает “exists: true/false” (без раскрытия ключей).
◦
POST /api/user/b2 — принимает креды, шифрует серверным ключом, сохраняет.
◦
(Опционально) POST /api/user/b2/test — проверка подключения (authorize + list bucket) без сохранения.
◦
Доступ: проверять userId на сервере (ID token/Firebase Admin) — сейчас у нас доверие к userId в теле, нужно перейти на проверку токена.
4)
Шифрование на сервере:
◦
В серверном коде: B2_SECRET_KEY (32 байта hex/base64) из env.
◦
AES-GCM: encrypt(plaintext-json, secret) -> base64(nonce + ciphertext + tag); decrypt аналогично.
◦
Соль/nonce генерировать для каждой записи.
◦
Хранить { payload: "<base64>", createdAt, updatedAt } в Firestore.
5)
Использование в существующих маршрутах:
◦
/api/b2/upload-url и /api/b2/file вместо чтения env читают B2 креды пользователя:
▪
Берут userId (после проверки токена).
▪
Достаём users/{uid}/settings/b2, расшифровываем.
▪
Используем полученные keyId, applicationKey, bucketId, bucketName как раньше.
◦
Ошибки: если кредов нет — 400/404 “B2 credentials not set”; если расшифровка не удалась — 500.
6)
Безопасность/UX:
◦
Приватный ключ шифрования хранится только как env на сервере, не уходит в бандл.
◦
Клиент никогда не получает B2 креды в ответе.
◦
Показывать пользователю только факт наличия/отсутствия B2 настроек и результат проверки.
7)
Миграции/дефолты:
◦
При загрузке /upload// проверять наличие настроек B2 (через новый GET /api/user/b2), если нет — блокировать загрузку с сообщением “добавьте B2 креды в Settings”.
◦
Старые env BLACKBAZE_* можно оставить как fallback для single-user режима (опционально), но цель — per-user хранилище.
8)
Проверка авторизации:
◦
Включить проверку ID токена Firebase на серверных маршрутах (переход с доверия к userId в теле).